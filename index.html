<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>ğŸ„ Merry Christmas</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%; height: 100%; overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "PingFang SC", sans-serif;
      touch-action: none;
    }
    #container { width: 100%; height: 100%; position: relative; }
    canvas { display: block; }

    /* åŠ è½½ç•Œé¢ */
    #loading {
      position: fixed; inset: 0; z-index: 1000;
      background: radial-gradient(ellipse at top, #1a0a2e 0%, #0d0015 100%);
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      color: #fff; transition: opacity 0.8s ease;
    }
    #loading.hidden { opacity: 0; pointer-events: none; }
    .loading-tree { font-size: 80px; animation: bounce 1s infinite; }
    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-20px); }
    }
    .loading-text { margin-top: 20px; font-size: 18px; opacity: 0.8; }
    .loading-hint { margin-top: 30px; font-size: 14px; opacity: 0.5; }

    /* UI æ§ä»¶ */
    #ui {
      position: fixed; bottom: 0; left: 0; right: 0;
      padding: 15px 10px 25px; z-index: 100;
      background: linear-gradient(to top, rgba(0,0,0,0.6) 0%, transparent 100%);
    }
    .title {
      text-align: center; color: #fff; font-size: 22px; font-weight: 600;
      text-shadow: 0 0 20px rgba(255,200,100,0.8), 0 0 40px rgba(255,150,50,0.5);
      margin-bottom: 15px; letter-spacing: 2px;
    }
    .btns {
      display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;
    }
    .btn {
      border: 1px solid rgba(255,255,255,0.3);
      background: rgba(255,255,255,0.1);
      backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
      color: #fff; padding: 10px 16px; border-radius: 25px;
      font-size: 14px; cursor: pointer;
      transition: all 0.3s ease;
      display: flex; align-items: center; gap: 6px;
    }
    .btn:hover { background: rgba(255,255,255,0.2); transform: scale(1.05); }
    .btn:active { transform: scale(0.95); }
    .btn.active { background: rgba(255,200,100,0.3); border-color: rgba(255,200,100,0.6); }

    /* æç¤ºæ–‡å­— */
    .hint {
      position: fixed; top: 15px; left: 50%; transform: translateX(-50%);
      color: rgba(255,255,255,0.6); font-size: 12px; text-align: center;
      pointer-events: none; z-index: 100;
    }

    /* ç‚¹å‡»æç¤º */
    .tap-hint {
      position: fixed; inset: 0; z-index: 999;
      background: rgba(0,0,0,0.7);
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      color: #fff; cursor: pointer;
    }
    .tap-hint.hidden { display: none; }
    .tap-icon { font-size: 60px; animation: pulse 1.5s infinite; }
    @keyframes pulse {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.1); opacity: 0.7; }
    }
    .tap-text { margin-top: 20px; font-size: 16px; }
  </style>
</head>
<body>
  <!-- åŠ è½½ç•Œé¢ -->
  <div id="loading">
    <div class="loading-tree">ğŸ„</div>
    <div class="loading-text">æ­£åœ¨å‡†å¤‡åœ£è¯æƒŠå–œ...</div>
    <div class="loading-hint">é¦–æ¬¡åŠ è½½å¯èƒ½éœ€è¦å‡ ç§’é’Ÿ</div>
  </div>

  <!-- ç‚¹å‡»å¼€å§‹æç¤º -->
  <div id="tap-hint" class="tap-hint hidden">
    <div class="tap-icon">ğŸ‘†</div>
    <div class="tap-text">ç‚¹å‡»å±å¹•å¼€å§‹ä½“éªŒ</div>
  </div>

  <!-- 3D å®¹å™¨ -->
  <div id="container"></div>

  <!-- é¡¶éƒ¨æç¤º -->
  <div class="hint">æ»‘åŠ¨æ—‹è½¬ Â· åŒæŒ‡ç¼©æ”¾ Â· ç‚¹å‡»æ”¾çƒŸèŠ±</div>

  <!-- åº•éƒ¨UI -->
  <div id="ui">
    <div class="title">âœ¨ Merry Christmas âœ¨</div>
    <div class="btns">
      <button class="btn" id="btn-regen">ğŸ„ æ¢ä¸€æ£µ</button>
      <button class="btn" id="btn-pause">â¸ï¸ æš‚åœ</button>
      <button class="btn" id="btn-music">ğŸµ éŸ³ä¹</button>
      <button class="btn" id="btn-reset">ğŸ”„ è§†è§’</button>
      <label class="btn" id="btn-upload">
        ğŸ“· æ·»åŠ å°äºº
        <input type="file" id="photo-input" accept="image/*" style="display:none" multiple>
      </label>
    </div>
  </div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// ============ é…ç½® ============
const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
const CONFIG = {
  snowCount: isMobile ? 200 : 400,
  confettiCount: isMobile ? 80 : 150,
  lightCount: isMobile ? 120 : 200,  // å¤§å¹…å¢åŠ å½©ç¯æ•°é‡
  ornamentCount: isMobile ? 30 : 50, // è£…é¥°çƒæ•°é‡
  starCount: isMobile ? 100 : 200,
  tinselCount: isMobile ? 6 : 10,    // é‡‘é“¶ä¸å¸¦æ•°é‡
};

// ============ å…¨å±€å˜é‡ ============
let scene, camera, renderer, controls;
let running = true;
let musicPlaying = false;
let audio;
let clock = new THREE.Clock();

// ç²’å­ç³»ç»Ÿ
let snowParticles, confettiParticles, starParticles;
let snowPositions, snowVelocities;
let confettiPositions, confettiVelocities, confettiRotations;

// å¯¹è±¡
let treeLights = [];
let ornaments = [];
let tinselLines = [];
let star;
let gifts = [];
let fireworks = [];
let meteors = [];
let aurora;
let treeGroup;
let dancers = [];

// ============ åˆå§‹åŒ– ============
function init() {
  // åœºæ™¯
  scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x0a0015, 0.015);

  // ç›¸æœº
  camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 3, 12);

  // æ¸²æŸ“å™¨
  renderer = new THREE.WebGLRenderer({
    antialias: !isMobile,
    alpha: true,
    powerPreference: 'high-performance'
  });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.2;
  document.getElementById('container').appendChild(renderer.domElement);

  // æ§åˆ¶å™¨
  controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;
  controls.maxDistance = 25;
  controls.minDistance = 5;
  controls.maxPolarAngle = Math.PI * 0.85;
  controls.minPolarAngle = Math.PI * 0.1;
  controls.autoRotate = true;
  controls.autoRotateSpeed = 0.08;
  controls.target.set(0, 2, 0);

  // å…‰ç…§
  setupLights();

  // åˆ›å»ºåœºæ™¯ç‰©ä½“
  createAurora();
  createStarField();
  createGround();
  createTree();
  createStar();
  createTreeLights();
  createOrnaments();
  createTinsel();
  createGifts();
  createDancers();
  createSnow();
  createConfetti();

  // äº‹ä»¶ç›‘å¬
  window.addEventListener('resize', onResize);
  renderer.domElement.addEventListener('click', onTap);
  renderer.domElement.addEventListener('touchend', onTap);

  // æŒ‰é’®äº‹ä»¶
  document.getElementById('btn-regen').addEventListener('click', regenerate);
  document.getElementById('btn-pause').addEventListener('click', togglePause);
  document.getElementById('btn-music').addEventListener('click', toggleMusic);
  document.getElementById('btn-reset').addEventListener('click', resetCamera);
  document.getElementById('photo-input').addEventListener('change', handlePhotoUpload);

  // éšè—åŠ è½½ç•Œé¢
  setTimeout(() => {
    document.getElementById('loading').classList.add('hidden');
    document.getElementById('tap-hint').classList.remove('hidden');
  }, 1500);

  // ç‚¹å‡»å¼€å§‹
  document.getElementById('tap-hint').addEventListener('click', startExperience);

  // è®¾ç½®éŸ³é¢‘
  setupAudio();

  // å¼€å§‹åŠ¨ç”»
  animate();
}

function setupLights() {
  // ç¯å¢ƒå…‰ - ç•¥å¾®å¢å¼º
  const ambient = new THREE.AmbientLight(0x404060, 0.5);
  scene.add(ambient);

  // ä¸»å…‰æº - ä»å³ä¸Šæ–¹ç…§å°„
  const mainLight = new THREE.DirectionalLight(0xffeedd, 0.6);
  mainLight.position.set(5, 10, 5);
  scene.add(mainLight);

  // âœ¨ æš–å…‰ç…§å°„åœ¨æ ‘ä¸Š - ä»å‰æ–¹æ–œä¸Šæ–¹
  const warmSpotLight = new THREE.SpotLight(0xffaa55, 1.5, 20, Math.PI / 6, 0.5, 1);
  warmSpotLight.position.set(3, 8, 8);
  warmSpotLight.target.position.set(0, 3, 0);
  scene.add(warmSpotLight);
  scene.add(warmSpotLight.target);

  // ç¬¬äºŒæŸæš–å…‰ - ä»å·¦ä¾§
  const warmSpotLight2 = new THREE.SpotLight(0xffcc77, 1.0, 18, Math.PI / 5, 0.6, 1);
  warmSpotLight2.position.set(-4, 6, 6);
  warmSpotLight2.target.position.set(0, 2, 0);
  scene.add(warmSpotLight2);
  scene.add(warmSpotLight2.target);

  // åº•éƒ¨æš–å…‰ - ç¤¼ç‰©åŒºåŸŸ
  const warmLight = new THREE.PointLight(0xff8844, 0.8, 15);
  warmLight.position.set(0, 0.5, 4);
  scene.add(warmLight);

  // é¡¶éƒ¨æ˜Ÿå…‰ - æ›´äº®æ›´æ¸©æš–
  const starLight = new THREE.PointLight(0xffffaa, 1.5, 12);
  starLight.position.set(0, 7.5, 0);
  scene.add(starLight);

  // èƒŒå…‰ - å¢åŠ å±‚æ¬¡æ„Ÿ
  const backLight = new THREE.PointLight(0x4466ff, 0.3, 20);
  backLight.position.set(0, 5, -8);
  scene.add(backLight);
}

// ============ æå…‰æ•ˆæœ ============
function createAurora() {
  const auroraGeo = new THREE.PlaneGeometry(100, 40, 50, 20);
  const auroraMat = new THREE.ShaderMaterial({
    uniforms: {
      uTime: { value: 0 },
      uColor1: { value: new THREE.Color(0x00ff88) },
      uColor2: { value: new THREE.Color(0x0088ff) },
      uColor3: { value: new THREE.Color(0xff00aa) },
    },
    vertexShader: `
      varying vec2 vUv;
      varying float vY;
      uniform float uTime;
      void main() {
        vUv = uv;
        vec3 pos = position;
        pos.z += sin(pos.x * 0.1 + uTime * 0.5) * 2.0;
        pos.z += sin(pos.y * 0.2 + uTime * 0.3) * 1.5;
        vY = pos.y;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
      }
    `,
    fragmentShader: `
      uniform float uTime;
      uniform vec3 uColor1;
      uniform vec3 uColor2;
      uniform vec3 uColor3;
      varying vec2 vUv;
      varying float vY;
      void main() {
        float wave = sin(vUv.x * 10.0 + uTime) * 0.5 + 0.5;
        float wave2 = sin(vUv.x * 5.0 - uTime * 0.7) * 0.5 + 0.5;
        vec3 color = mix(uColor1, uColor2, wave);
        color = mix(color, uColor3, wave2 * 0.3);
        float alpha = smoothstep(0.0, 0.5, vUv.y) * smoothstep(1.0, 0.6, vUv.y);
        alpha *= 0.3 + wave * 0.2;
        alpha *= smoothstep(-20.0, 0.0, vY);
        gl_FragColor = vec4(color, alpha * 0.4);
      }
    `,
    transparent: true,
    side: THREE.DoubleSide,
    depthWrite: false,
  });

  aurora = new THREE.Mesh(auroraGeo, auroraMat);
  aurora.position.set(0, 25, -40);
  aurora.rotation.x = Math.PI * 0.1;
  scene.add(aurora);
}

// ============ æ˜Ÿç©ºèƒŒæ™¯ ============
function createStarField() {
  const geometry = new THREE.BufferGeometry();
  const positions = new Float32Array(CONFIG.starCount * 3);
  const sizes = new Float32Array(CONFIG.starCount);

  for (let i = 0; i < CONFIG.starCount; i++) {
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.random() * Math.PI * 0.5;
    const r = 50 + Math.random() * 50;

    positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
    positions[i * 3 + 1] = r * Math.cos(phi) + 10;
    positions[i * 3 + 2] = r * Math.sin(phi) * Math.sin(theta) - 20;
    sizes[i] = Math.random() * 2 + 0.5;
  }

  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

  const material = new THREE.ShaderMaterial({
    uniforms: {
      uTime: { value: 0 },
    },
    vertexShader: `
      attribute float size;
      varying float vSize;
      void main() {
        vSize = size;
        vec4 mvPos = modelViewMatrix * vec4(position, 1.0);
        gl_PointSize = size * (200.0 / -mvPos.z);
        gl_Position = projectionMatrix * mvPos;
      }
    `,
    fragmentShader: `
      uniform float uTime;
      varying float vSize;
      void main() {
        float d = length(gl_PointCoord - 0.5);
        if (d > 0.5) discard;
        float alpha = 1.0 - d * 2.0;
        float twinkle = sin(uTime * 3.0 + vSize * 10.0) * 0.3 + 0.7;
        gl_FragColor = vec4(1.0, 1.0, 0.95, alpha * twinkle);
      }
    `,
    transparent: true,
    depthWrite: false,
  });

  starParticles = new THREE.Points(geometry, material);
  scene.add(starParticles);
}

// ============ åœ°é¢ ============
function createGround() {
  const groundGeo = new THREE.CircleGeometry(30, 64);
  const groundMat = new THREE.MeshStandardMaterial({
    color: 0xffffff,
    roughness: 0.9,
    metalness: 0.1,
  });
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI / 2;
  ground.position.y = -0.5;
  ground.receiveShadow = true;
  scene.add(ground);
}

// ============ åœ£è¯æ ‘ ============
function createTree() {
  treeGroup = new THREE.Group();

  // æ›´ä¸°å¯Œçš„æ ‘å¶æè´¨
  const treeMaterial = new THREE.MeshStandardMaterial({
    color: 0x1a7a3a,
    roughness: 0.7,
    metalness: 0.05,
  });

  const darkTreeMaterial = new THREE.MeshStandardMaterial({
    color: 0x0f5528,
    roughness: 0.75,
    metalness: 0.05,
  });

  const lightTreeMaterial = new THREE.MeshStandardMaterial({
    color: 0x2a9a4a,
    roughness: 0.65,
    metalness: 0.05,
  });

  // æ›´å¤šå±‚æ¬¡çš„æ ‘å†  - 7å±‚ï¼Œæ›´åŠ é¥±æ»¡
  const layers = [
    { y: 6.2, radius: 0.5, height: 1.2 },   // é¡¶éƒ¨å°–
    { y: 5.6, radius: 0.8, height: 1.4 },
    { y: 4.8, radius: 1.1, height: 1.6 },
    { y: 3.9, radius: 1.5, height: 1.8 },
    { y: 2.9, radius: 1.9, height: 2.0 },
    { y: 1.8, radius: 2.3, height: 2.2 },
    { y: 0.6, radius: 2.8, height: 2.4 },   // åº•éƒ¨å®½
  ];

  const materials = [treeMaterial, darkTreeMaterial, lightTreeMaterial];

  layers.forEach((layer, i) => {
    // ä¸»åœ†é”¥
    const geo = new THREE.ConeGeometry(layer.radius, layer.height, 32);
    const mat = materials[i % 3];
    const cone = new THREE.Mesh(geo, mat);
    cone.position.y = layer.y;
    cone.castShadow = true;
    treeGroup.add(cone);

    // æ·»åŠ ä¸€äº›éšæœºçš„å°çªèµ·ï¼Œè®©æ ‘çœ‹èµ·æ¥æ›´è‡ªç„¶
    if (i > 0 && i < layers.length - 1) {
      const bumpCount = 5 + i * 2;
      for (let j = 0; j < bumpCount; j++) {
        const angle = (j / bumpCount) * Math.PI * 2 + Math.random() * 0.3;
        const bumpGeo = new THREE.ConeGeometry(layer.radius * 0.25, layer.height * 0.4, 8);
        const bump = new THREE.Mesh(bumpGeo, materials[(i + j) % 3]);
        const r = layer.radius * 0.85;
        bump.position.set(
          Math.cos(angle) * r,
          layer.y - layer.height * 0.1 + Math.random() * 0.2,
          Math.sin(angle) * r
        );
        bump.rotation.x = (Math.random() - 0.5) * 0.3;
        bump.rotation.z = (Math.random() - 0.5) * 0.3;
        treeGroup.add(bump);
      }
    }
  });

  // æ ‘å¹² - æ›´ç²—å£®ï¼Œæœ‰çº¹ç†æ„Ÿ
  const trunkGeo = new THREE.CylinderGeometry(0.25, 0.4, 1.4, 16);
  const trunkMat = new THREE.MeshStandardMaterial({
    color: 0x5a3825,
    roughness: 0.95,
    metalness: 0,
  });
  const trunk = new THREE.Mesh(trunkGeo, trunkMat);
  trunk.position.y = -0.3;
  treeGroup.add(trunk);

  // æ ‘æ ¹è£…é¥°
  const rootGeo = new THREE.TorusGeometry(0.5, 0.15, 8, 16);
  const rootMat = new THREE.MeshStandardMaterial({
    color: 0x4a3020,
    roughness: 0.9,
  });
  const root = new THREE.Mesh(rootGeo, rootMat);
  root.position.y = -0.45;
  root.rotation.x = Math.PI / 2;
  treeGroup.add(root);

  scene.add(treeGroup);
}

// ============ æ ‘é¡¶æ˜Ÿæ˜Ÿ ============
function createStar() {
  const starShape = new THREE.Shape();
  const outerRadius = 0.6;
  const innerRadius = 0.25;
  const spikes = 5;

  for (let i = 0; i < spikes * 2; i++) {
    const radius = i % 2 === 0 ? outerRadius : innerRadius;
    const angle = (i * Math.PI) / spikes - Math.PI / 2;
    const x = Math.cos(angle) * radius;
    const y = Math.sin(angle) * radius;
    if (i === 0) starShape.moveTo(x, y);
    else starShape.lineTo(x, y);
  }
  starShape.closePath();

  const extrudeSettings = { depth: 0.2, bevelEnabled: true, bevelSize: 0.08, bevelThickness: 0.08 };
  const starGeo = new THREE.ExtrudeGeometry(starShape, extrudeSettings);
  const starMat = new THREE.MeshStandardMaterial({
    color: 0xffd700,
    emissive: 0xffcc00,
    emissiveIntensity: 1.2,
    roughness: 0.2,
    metalness: 0.9,
  });

  star = new THREE.Mesh(starGeo, starMat);
  star.position.set(0, 7.0, 0);
  star.rotation.y = Math.PI / 2;
  scene.add(star);

  // å¤šå±‚å…‰æ™•æ•ˆæœ
  const glowGeo = new THREE.SphereGeometry(0.5, 16, 16);
  const glowMat = new THREE.MeshBasicMaterial({
    color: 0xffee66,
    transparent: true,
    opacity: 0.4,
  });
  const glow = new THREE.Mesh(glowGeo, glowMat);
  glow.position.copy(star.position);
  scene.add(glow);

  // å¤–å±‚æŸ”å’Œå…‰æ™•
  const outerGlowGeo = new THREE.SphereGeometry(1.0, 16, 16);
  const outerGlowMat = new THREE.MeshBasicMaterial({
    color: 0xffdd44,
    transparent: true,
    opacity: 0.15,
  });
  const outerGlow = new THREE.Mesh(outerGlowGeo, outerGlowMat);
  outerGlow.position.copy(star.position);
  scene.add(outerGlow);
}

// ============ å½©ç¯ ============
function createTreeLights() {
  treeLights.forEach(light => scene.remove(light));
  treeLights = [];

  const colors = [
    0xff3333, 0xff6633, 0xffcc00, // æš–è‰²
    0x33ff66, 0x33ffcc,           // ç»¿è‰²
    0x3366ff, 0x6633ff, 0xff33ff, // å†·è‰²
    0xffffff, 0xffffcc,           // ç™½è‰²
  ];

  // æ›´å¯†é›†çš„å½©ç¯åˆ†å¸ƒ
  for (let i = 0; i < CONFIG.lightCount; i++) {
    // å‡åŒ€åˆ†å¸ƒåœ¨æ ‘çš„å„å±‚
    const t = i / CONFIG.lightCount;
    const y = 0.3 + t * 6.2;

    // æ ¹æ®é«˜åº¦è®¡ç®—åŠå¾„ï¼ˆæ ‘çš„é”¥å½¢ï¼‰
    const treeRadius = 2.8 * (1 - t * 0.82);
    const angle = (i * 2.39996) + Math.random() * 0.5; // é»„é‡‘è§’åº¦åˆ†å¸ƒ
    const radius = treeRadius * (0.85 + Math.random() * 0.15);

    const x = Math.cos(angle) * radius;
    const z = Math.sin(angle) * radius;

    // å½©ç¯çƒä½“ - æ›´å¤§æ›´æ˜æ˜¾
    const geometry = new THREE.SphereGeometry(0.06 + Math.random() * 0.04, 8, 8);
    const color = colors[Math.floor(Math.random() * colors.length)];
    const material = new THREE.MeshBasicMaterial({
      color: color,
      transparent: true,
    });

    const light = new THREE.Mesh(geometry, material);
    light.position.set(x, y, z);
    light.userData = {
      baseColor: color,
      phase: Math.random() * Math.PI * 2,
      speed: 1.5 + Math.random() * 2.5,
    };

    scene.add(light);
    treeLights.push(light);
  }
}

// ============ è£…é¥°çƒ ============
function createOrnaments() {
  ornaments.forEach(o => scene.remove(o));
  ornaments = [];

  const ornamentColors = [
    { color: 0xff0000, emissive: 0x330000 }, // çº¢
    { color: 0xffd700, emissive: 0x332200 }, // é‡‘
    { color: 0xc0c0c0, emissive: 0x222222 }, // é“¶
    { color: 0x0066ff, emissive: 0x001133 }, // è“
    { color: 0xff00ff, emissive: 0x220022 }, // ç´«
    { color: 0x00ff88, emissive: 0x002211 }, // ç»¿
  ];

  for (let i = 0; i < CONFIG.ornamentCount; i++) {
    const t = Math.random();
    const y = 0.5 + t * 5.8;
    const treeRadius = 2.6 * (1 - t * 0.8);
    const angle = Math.random() * Math.PI * 2;
    const radius = treeRadius * (0.75 + Math.random() * 0.25);

    const x = Math.cos(angle) * radius;
    const z = Math.sin(angle) * radius;

    // è£…é¥°çƒ - æœ‰å…‰æ³½çš„å¤§çƒ
    const size = 0.12 + Math.random() * 0.1;
    const geometry = new THREE.SphereGeometry(size, 16, 16);
    const colorData = ornamentColors[Math.floor(Math.random() * ornamentColors.length)];
    const material = new THREE.MeshStandardMaterial({
      color: colorData.color,
      emissive: colorData.emissive,
      emissiveIntensity: 0.3,
      roughness: 0.2,
      metalness: 0.8,
    });

    const ornament = new THREE.Mesh(geometry, material);
    ornament.position.set(x, y, z);
    ornament.userData = {
      phase: Math.random() * Math.PI * 2,
      swingSpeed: 0.5 + Math.random() * 0.5,
    };

    scene.add(ornament);
    ornaments.push(ornament);
  }
}

// ============ é‡‘é“¶ä¸å¸¦/å½©å¸¦ç¼ ç»• ============
function createTinsel() {
  tinselLines.forEach(t => scene.remove(t));
  tinselLines = [];

  const tinselColors = [0xffd700, 0xc0c0c0, 0xff6666, 0x66ff66];

  for (let t = 0; t < CONFIG.tinselCount; t++) {
    const points = [];
    const startAngle = (t / CONFIG.tinselCount) * Math.PI * 2;
    const rotations = 2 + Math.random(); // ç¼ ç»•åœˆæ•°

    // èºæ—‹ç¼ ç»•
    for (let i = 0; i <= 60; i++) {
      const progress = i / 60;
      const y = 0.5 + progress * 6;
      const treeRadius = 2.7 * (1 - progress * 0.8);
      const angle = startAngle + progress * Math.PI * 2 * rotations;
      const r = treeRadius * (0.9 + Math.sin(progress * 10) * 0.1);

      points.push(new THREE.Vector3(
        Math.cos(angle) * r,
        y,
        Math.sin(angle) * r
      ));
    }

    const curve = new THREE.CatmullRomCurve3(points);
    const geometry = new THREE.TubeGeometry(curve, 80, 0.03, 6, false);
    const material = new THREE.MeshStandardMaterial({
      color: tinselColors[t % tinselColors.length],
      emissive: tinselColors[t % tinselColors.length],
      emissiveIntensity: 0.2,
      roughness: 0.3,
      metalness: 0.7,
    });

    const tinsel = new THREE.Mesh(geometry, material);
    scene.add(tinsel);
    tinselLines.push(tinsel);
  }
}

// ============ è·³èˆå°äººï¼ˆå‘å…‰çº¿æ¡ç‰ˆï¼‰ ============
class DancingPerson {
  constructor(photoUrl, posX, posZ, lineColor, danceStyle) {
    this.group = new THREE.Group();
    this.danceStyle = danceStyle;
    this.time = Math.random() * 100;
    this.lineColor = lineColor;

    // å‘å…‰çº¿æ¡æè´¨ - ä½¿ç”¨ MeshBasicMaterial æ¨¡æ‹Ÿå‘å…‰
    const glowMat = new THREE.MeshBasicMaterial({
      color: lineColor,
      transparent: true,
      opacity: 0.9,
    });

    // åŠ è½½å¤´åƒçº¹ç†
    const textureLoader = new THREE.TextureLoader();
    const headTexture = textureLoader.load(photoUrl);

    // å¤´éƒ¨ - åœ†å½¢ç…§ç‰‡
    const headGeo = new THREE.CircleGeometry(0.4, 16);
    const headMat = new THREE.MeshBasicMaterial({
      map: headTexture,
      side: THREE.DoubleSide,
    });
    this.head = new THREE.Mesh(headGeo, headMat);
    this.head.position.y = 1.6;
    this.group.add(this.head);

    // å¤´éƒ¨å‘å…‰è¾¹æ¡†
    const headRingGeo = new THREE.RingGeometry(0.38, 0.45, 24);
    const headRingMat = new THREE.MeshBasicMaterial({
      color: lineColor,
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 0.8,
    });
    this.headRing = new THREE.Mesh(headRingGeo, headRingMat);
    this.headRing.position.y = 1.6;
    this.group.add(this.headRing);

    // èº«ä½“ - ç”¨ç²—çš„å‘å…‰æ¡å¸¦ä»£æ›¿çº¿æ¡
    const bodyGeo = new THREE.PlaneGeometry(0.12, 0.8);
    this.body = new THREE.Mesh(bodyGeo, glowMat);
    this.body.position.y = 0.8;
    this.group.add(this.body);

    // å·¦æ‰‹è‡‚ - å‘å…‰æ¡å¸¦
    const armGeo = new THREE.PlaneGeometry(0.08, 0.5);
    this.leftArm = new THREE.Mesh(armGeo, glowMat);
    this.leftArm.position.set(-0.25, 0.85, 0);
    this.leftArm.rotation.z = 0.5;
    this.group.add(this.leftArm);

    // å³æ‰‹è‡‚
    this.rightArm = new THREE.Mesh(armGeo, glowMat);
    this.rightArm.position.set(0.25, 0.85, 0);
    this.rightArm.rotation.z = -0.5;
    this.group.add(this.rightArm);

    // å·¦è…¿ - å‘å…‰æ¡å¸¦
    const legGeo = new THREE.PlaneGeometry(0.1, 0.55);
    this.leftLeg = new THREE.Mesh(legGeo, glowMat);
    this.leftLeg.position.set(-0.1, 0.12, 0);
    this.leftLeg.rotation.z = 0.15;
    this.group.add(this.leftLeg);

    // å³è…¿
    this.rightLeg = new THREE.Mesh(legGeo, glowMat);
    this.rightLeg.position.set(0.1, 0.12, 0);
    this.rightLeg.rotation.z = -0.15;
    this.group.add(this.rightLeg);

    // æ‰‹éƒ¨å‘å…‰çƒ
    const handGeo = new THREE.CircleGeometry(0.06, 8);
    const handMat = new THREE.MeshBasicMaterial({ color: 0xffddaa, side: THREE.DoubleSide });
    this.leftHand = new THREE.Mesh(handGeo, handMat);
    this.leftHand.position.set(-0.45, 0.65, 0);
    this.group.add(this.leftHand);

    this.rightHand = new THREE.Mesh(handGeo, handMat);
    this.rightHand.position.set(0.45, 0.65, 0);
    this.group.add(this.rightHand);

    // è„šéƒ¨å‘å…‰
    const footGeo = new THREE.CircleGeometry(0.08, 8);
    const footMat = new THREE.MeshBasicMaterial({ color: 0x333333, side: THREE.DoubleSide });
    this.leftFoot = new THREE.Mesh(footGeo, footMat);
    this.leftFoot.position.set(-0.12, -0.15, 0);
    this.group.add(this.leftFoot);

    this.rightFoot = new THREE.Mesh(footGeo, footMat);
    this.rightFoot.position.set(0.12, -0.15, 0);
    this.group.add(this.rightFoot);

    // è®¾ç½®ä½ç½®
    this.group.position.set(posX, -0.45, posZ);
    this.baseY = -0.45;

    scene.add(this.group);
  }

  update(time) {
    this.time += 0.016;
    const t = this.time;

    // å¤´éƒ¨å’Œè¾¹æ¡†å§‹ç»ˆé¢å‘ç›¸æœº
    if (camera) {
      this.head.lookAt(camera.position);
      this.headRing.lookAt(camera.position);
    }

    if (this.danceStyle === 1) {
      // èˆè¹ˆé£æ ¼1ï¼šç–¯ç‹‚è¹¦è·³

      // å¼¹è·³
      const bounce = Math.abs(Math.sin(t * 8)) * 0.3;
      this.group.position.y = this.baseY + bounce;

      // å·¦å³æ‘‡æ‘†
      this.group.rotation.z = Math.sin(t * 6) * 0.15;
      this.body.rotation.z = Math.sin(t * 8) * 0.1;

      // æ‰‹è‡‚ç–¯ç‹‚æŒ¥èˆ
      this.leftArm.rotation.z = Math.sin(t * 10) * 1.2 + 0.8;
      this.leftArm.position.x = -0.2 + Math.sin(t * 10) * 0.1;
      this.leftArm.position.y = 0.85 + Math.cos(t * 10) * 0.15;

      this.rightArm.rotation.z = Math.cos(t * 9) * 1.2 - 0.8;
      this.rightArm.position.x = 0.2 + Math.cos(t * 9) * 0.1;
      this.rightArm.position.y = 0.85 + Math.sin(t * 9) * 0.15;

      // æ‰‹è·Ÿéšæ‰‹è‡‚
      this.leftHand.position.x = -0.2 + Math.sin(this.leftArm.rotation.z) * 0.4;
      this.leftHand.position.y = 0.85 - Math.cos(this.leftArm.rotation.z) * 0.4;
      this.rightHand.position.x = 0.2 - Math.sin(this.rightArm.rotation.z) * 0.4;
      this.rightHand.position.y = 0.85 + Math.cos(this.rightArm.rotation.z) * 0.4;

      // è…¿éƒ¨è¸¢è…¿
      this.leftLeg.rotation.z = Math.sin(t * 8) * 0.6 + 0.15;
      this.rightLeg.rotation.z = Math.sin(t * 8 + Math.PI) * 0.6 - 0.15;

      // è„šè·Ÿéšè…¿
      this.leftFoot.position.x = -0.1 + Math.sin(this.leftLeg.rotation.z) * 0.25;
      this.leftFoot.position.y = -0.15 - Math.abs(Math.sin(t * 8)) * 0.15;
      this.rightFoot.position.x = 0.1 - Math.sin(this.rightLeg.rotation.z) * 0.25;
      this.rightFoot.position.y = -0.15 - Math.abs(Math.sin(t * 8 + Math.PI)) * 0.15;

      // å¶å°”è½¬åœˆ
      if (Math.sin(t * 0.5) > 0.8) {
        this.group.rotation.y += 0.08;
      }

    } else {
      // èˆè¹ˆé£æ ¼2ï¼šæ‰­åŠ¨æ³¢æµª

      // å°å¹…å¼¹è·³
      const bounce = Math.abs(Math.sin(t * 6)) * 0.15;
      this.group.position.y = this.baseY + bounce;

      // èº«ä½“æ‰­åŠ¨
      this.group.rotation.y = Math.sin(t * 3) * 0.3;
      this.body.rotation.z = Math.sin(t * 4) * 0.08;

      // æ‰‹è‡‚æ³¢æµªèˆ
      this.leftArm.rotation.z = Math.sin(t * 4) * 0.6 + 1.0;
      this.rightArm.rotation.z = Math.sin(t * 4 + 2) * 0.6 - 1.0;

      // æ‰‹è·Ÿéš
      this.leftHand.position.x = -0.2 + Math.sin(this.leftArm.rotation.z) * 0.4;
      this.leftHand.position.y = 0.85 - Math.cos(this.leftArm.rotation.z) * 0.35;
      this.rightHand.position.x = 0.2 - Math.sin(this.rightArm.rotation.z) * 0.4;
      this.rightHand.position.y = 0.85 + Math.cos(this.rightArm.rotation.z) * 0.35;

      // è…¿éƒ¨äº¤æ›¿æŠ¬èµ·
      this.leftLeg.rotation.z = Math.max(0, Math.sin(t * 6)) * 0.4 + 0.1;
      this.rightLeg.rotation.z = Math.max(0, Math.sin(t * 6 + Math.PI)) * 0.4 - 0.1;

      // è„šè·Ÿéš
      const leftUp = Math.max(0, Math.sin(t * 6)) * 0.2;
      const rightUp = Math.max(0, Math.sin(t * 6 + Math.PI)) * 0.2;
      this.leftFoot.position.y = -0.15 + leftUp;
      this.rightFoot.position.y = -0.15 + rightUp;

      // å¤´éƒ¨è½»å¾®æ‘‡åŠ¨
      this.head.rotation.z = Math.sin(t * 5) * 0.12;
      this.headRing.rotation.z = Math.sin(t * 5) * 0.12;
    }
  }
}

function createDancers() {
  // æ¸…é™¤æ—§çš„
  dancers.forEach(d => scene.remove(d.group));
  dancers = [];

  // é»˜è®¤åˆ›å»ºä¸¤ä¸ªè·³èˆå°äººï¼ˆå¦‚æœç…§ç‰‡å­˜åœ¨ï¼‰
  // cjs - å·¦è¾¹ï¼Œçº¢è‰²è¡£æœï¼Œèˆè¹ˆé£æ ¼1ï¼ˆç–¯ç‹‚è¹¦è·³ï¼‰
  const dancer1 = new DancingPerson('./cjs.jpg', -2.5, 4, 0xcc2222, 1);
  dancers.push(dancer1);

  // wb - å³è¾¹ï¼Œç»¿è‰²è¡£æœï¼Œèˆè¹ˆé£æ ¼2ï¼ˆæ‰­åŠ¨æ³¢æµªï¼‰
  const dancer2 = new DancingPerson('./wb.jpg', 2.5, 4, 0x22aa22, 2);
  dancers.push(dancer2);
}

// ç”¨æˆ·ä¸Šä¼ ç…§ç‰‡å¤„ç†
let uploadedDancerCount = 0;
const dancerColors = [0xff6666, 0x66ff66, 0x6666ff, 0xffff66, 0xff66ff, 0x66ffff, 0xffaa00, 0xaa00ff];

// å‹ç¼©å›¾ç‰‡åˆ°æŒ‡å®šå°ºå¯¸
function compressImage(file, maxSize = 256) {
  return new Promise((resolve) => {
    const reader = new FileReader();
    reader.onload = function(e) {
      const img = new Image();
      img.onload = function() {
        // åˆ›å»º canvas å‹ç¼©å›¾ç‰‡
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹ï¼Œä¿æŒæ­£æ–¹å½¢è£å‰ª
        const size = Math.min(img.width, img.height);
        const sx = (img.width - size) / 2;
        const sy = (img.height - size) / 2;

        canvas.width = maxSize;
        canvas.height = maxSize;

        // è£å‰ªä¸ºæ­£æ–¹å½¢å¹¶ç¼©æ”¾
        ctx.drawImage(img, sx, sy, size, size, 0, 0, maxSize, maxSize);

        // è½¬ä¸º base64ï¼Œè´¨é‡ 0.7
        const compressedUrl = canvas.toDataURL('image/jpeg', 0.7);
        resolve(compressedUrl);
      };
      img.src = e.target.result;
    };
    reader.readAsDataURL(file);
  });
}

function handlePhotoUpload(event) {
  const files = event.target.files;
  if (!files || files.length === 0) return;

  Array.from(files).forEach(async (file) => {
    if (!file.type.startsWith('image/')) return;

    // å‹ç¼©å›¾ç‰‡åˆ° 256x256
    const compressedUrl = await compressImage(file, 256);
    addNewDancer(compressedUrl);
  });

  // æ¸…ç©º input ä»¥ä¾¿å¯ä»¥å†æ¬¡é€‰æ‹©ç›¸åŒæ–‡ä»¶
  event.target.value = '';
}

function addNewDancer(imageUrl) {
  // è®¡ç®—æ–°å°äººçš„ä½ç½®ï¼ˆå›´ç»•æ ‘çš„å‰æ–¹åŠåœ†åˆ†å¸ƒï¼‰
  const totalDancers = dancers.length;
  const angle = (Math.PI / 6) * (totalDancers % 6 - 2.5); // -75Â° åˆ° 75Â° åˆ†å¸ƒ
  const distance = 4 + Math.floor(totalDancers / 6) * 1.5; // å¤šæ’æ—¶å¾€åç«™

  const posX = Math.sin(angle) * distance;
  const posZ = Math.cos(angle) * distance;

  // éšæœºé€‰æ‹©é¢œè‰²å’Œèˆè¹ˆé£æ ¼
  const color = dancerColors[uploadedDancerCount % dancerColors.length];
  const danceStyle = (uploadedDancerCount % 2) + 1;

  const newDancer = new DancingPerson(imageUrl, posX, posZ, color, danceStyle);
  dancers.push(newDancer);
  uploadedDancerCount++;
}

// ============ ç¤¼ç‰©ç›’ ============
function createGifts() {
  gifts.forEach(g => scene.remove(g));
  gifts = [];

  const giftData = [
    { pos: [-1.5, 0, 2], size: [0.6, 0.5, 0.6], color: 0xff4444, ribbon: 0xffd700 },
    { pos: [0, 0, 2.5], size: [0.8, 0.7, 0.8], color: 0x4444ff, ribbon: 0xffffff },
    { pos: [1.8, 0, 1.8], size: [0.5, 0.4, 0.5], color: 0x44ff44, ribbon: 0xff4444 },
    { pos: [0.8, 0, 2.8], size: [0.55, 0.45, 0.55], color: 0xff44ff, ribbon: 0x44ffff },
  ];

  giftData.forEach(data => {
    const group = new THREE.Group();

    // ç›’å­
    const boxGeo = new THREE.BoxGeometry(...data.size);
    const boxMat = new THREE.MeshStandardMaterial({
      color: data.color,
      roughness: 0.4,
      metalness: 0.3,
    });
    const box = new THREE.Mesh(boxGeo, boxMat);
    box.position.y = data.size[1] / 2;
    group.add(box);

    // ä¸å¸¦
    const ribbonMat = new THREE.MeshStandardMaterial({
      color: data.ribbon,
      roughness: 0.3,
      metalness: 0.5,
    });

    const ribbonV = new THREE.Mesh(
      new THREE.BoxGeometry(data.size[0] * 0.15, data.size[1] * 1.02, data.size[2] * 1.02),
      ribbonMat
    );
    ribbonV.position.y = data.size[1] / 2;
    group.add(ribbonV);

    const ribbonH = new THREE.Mesh(
      new THREE.BoxGeometry(data.size[0] * 1.02, data.size[1] * 0.15, data.size[2] * 1.02),
      ribbonMat
    );
    ribbonH.position.y = data.size[1] / 2;
    group.add(ribbonH);

    group.position.set(...data.pos);
    group.userData.baseY = data.pos[1];
    group.userData.bouncePhase = Math.random() * Math.PI * 2;

    scene.add(group);
    gifts.push(group);
  });
}

// ============ é›ªèŠ±ç²’å­ ============
function createSnow() {
  if (snowParticles) scene.remove(snowParticles);

  const geometry = new THREE.BufferGeometry();
  snowPositions = new Float32Array(CONFIG.snowCount * 3);
  snowVelocities = [];

  for (let i = 0; i < CONFIG.snowCount; i++) {
    snowPositions[i * 3] = (Math.random() - 0.5) * 40;
    snowPositions[i * 3 + 1] = Math.random() * 30;
    snowPositions[i * 3 + 2] = (Math.random() - 0.5) * 40;

    snowVelocities.push({
      y: 0.02 + Math.random() * 0.03,
      x: (Math.random() - 0.5) * 0.01,
      z: (Math.random() - 0.5) * 0.01,
    });
  }

  geometry.setAttribute('position', new THREE.BufferAttribute(snowPositions, 3));

  const material = new THREE.PointsMaterial({
    color: 0xffffff,
    size: 0.15,
    transparent: true,
    opacity: 0.8,
    depthWrite: false,
  });

  snowParticles = new THREE.Points(geometry, material);
  scene.add(snowParticles);
}

// ============ å½©å¸¦ç²’å­ ============
function createConfetti() {
  if (confettiParticles) scene.remove(confettiParticles);

  const geometry = new THREE.BufferGeometry();
  confettiPositions = new Float32Array(CONFIG.confettiCount * 3);
  const colors = new Float32Array(CONFIG.confettiCount * 3);
  confettiVelocities = [];
  confettiRotations = [];

  const confettiColors = [
    new THREE.Color(0xff4444),
    new THREE.Color(0x44ff44),
    new THREE.Color(0x4444ff),
    new THREE.Color(0xffff44),
    new THREE.Color(0xff44ff),
    new THREE.Color(0x44ffff),
  ];

  for (let i = 0; i < CONFIG.confettiCount; i++) {
    confettiPositions[i * 3] = (Math.random() - 0.5) * 30;
    confettiPositions[i * 3 + 1] = 10 + Math.random() * 20;
    confettiPositions[i * 3 + 2] = (Math.random() - 0.5) * 30;

    const color = confettiColors[Math.floor(Math.random() * confettiColors.length)];
    colors[i * 3] = color.r;
    colors[i * 3 + 1] = color.g;
    colors[i * 3 + 2] = color.b;

    confettiVelocities.push({
      y: 0.01 + Math.random() * 0.02,
      x: (Math.random() - 0.5) * 0.02,
      z: (Math.random() - 0.5) * 0.02,
      swing: Math.random() * Math.PI * 2,
      swingSpeed: 0.02 + Math.random() * 0.03,
    });
  }

  geometry.setAttribute('position', new THREE.BufferAttribute(confettiPositions, 3));
  geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

  const material = new THREE.PointsMaterial({
    size: 0.2,
    vertexColors: true,
    transparent: true,
    opacity: 0.9,
    depthWrite: false,
  });

  confettiParticles = new THREE.Points(geometry, material);
  scene.add(confettiParticles);
}

// ============ çƒŸèŠ±ç³»ç»Ÿ ============
class Firework {
  constructor(x, y, z) {
    this.particles = [];
    this.geometry = new THREE.BufferGeometry();
    this.particleCount = isMobile ? 50 : 100;
    this.positions = new Float32Array(this.particleCount * 3);
    this.velocities = [];
    this.life = 1;
    this.decay = 0.015;

    const color = new THREE.Color().setHSL(Math.random(), 1, 0.6);

    for (let i = 0; i < this.particleCount; i++) {
      this.positions[i * 3] = x;
      this.positions[i * 3 + 1] = y;
      this.positions[i * 3 + 2] = z;

      const theta = Math.random() * Math.PI * 2;
      const phi = Math.random() * Math.PI;
      const speed = 0.1 + Math.random() * 0.15;

      this.velocities.push({
        x: Math.sin(phi) * Math.cos(theta) * speed,
        y: Math.sin(phi) * Math.sin(theta) * speed,
        z: Math.cos(phi) * speed,
      });
    }

    this.geometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));

    this.material = new THREE.PointsMaterial({
      color: color,
      size: 0.15,
      transparent: true,
      opacity: 1,
      depthWrite: false,
    });

    this.points = new THREE.Points(this.geometry, this.material);
    scene.add(this.points);
  }

  update() {
    this.life -= this.decay;
    this.material.opacity = this.life;

    for (let i = 0; i < this.particleCount; i++) {
      this.positions[i * 3] += this.velocities[i].x;
      this.positions[i * 3 + 1] += this.velocities[i].y;
      this.positions[i * 3 + 2] += this.velocities[i].z;

      this.velocities[i].y -= 0.002; // é‡åŠ›
      this.velocities[i].x *= 0.98;
      this.velocities[i].z *= 0.98;
    }

    this.geometry.attributes.position.needsUpdate = true;

    return this.life > 0;
  }

  dispose() {
    scene.remove(this.points);
    this.geometry.dispose();
    this.material.dispose();
  }
}

// ============ æµæ˜Ÿç³»ç»Ÿ ============
class Meteor {
  constructor() {
    this.geometry = new THREE.BufferGeometry();
    const trailLength = 20;
    this.positions = new Float32Array(trailLength * 3);

    this.startX = 20 + Math.random() * 10;
    this.startY = 15 + Math.random() * 10;
    this.startZ = -20 + Math.random() * 10;

    this.speed = 0.5 + Math.random() * 0.3;
    this.progress = 0;
    this.trailLength = trailLength;

    for (let i = 0; i < trailLength; i++) {
      this.positions[i * 3] = this.startX;
      this.positions[i * 3 + 1] = this.startY;
      this.positions[i * 3 + 2] = this.startZ;
    }

    this.geometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));

    this.material = new THREE.LineBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.8,
    });

    this.line = new THREE.Line(this.geometry, this.material);
    scene.add(this.line);
  }

  update() {
    this.progress += this.speed;

    const headX = this.startX - this.progress * 0.8;
    const headY = this.startY - this.progress * 0.4;
    const headZ = this.startZ + this.progress * 0.2;

    for (let i = this.trailLength - 1; i > 0; i--) {
      this.positions[i * 3] = this.positions[(i - 1) * 3];
      this.positions[i * 3 + 1] = this.positions[(i - 1) * 3 + 1];
      this.positions[i * 3 + 2] = this.positions[(i - 1) * 3 + 2];
    }

    this.positions[0] = headX;
    this.positions[1] = headY;
    this.positions[2] = headZ;

    this.geometry.attributes.position.needsUpdate = true;

    this.material.opacity = Math.max(0, 1 - this.progress / 40);

    return this.progress < 50;
  }

  dispose() {
    scene.remove(this.line);
    this.geometry.dispose();
    this.material.dispose();
  }
}

// ============ éŸ³é¢‘ç³»ç»Ÿ ============
function setupAudio() {
  audio = new Audio();
  audio.src = './Mariah Carey - All I Want for Christmas Is You.flac';
  audio.loop = true;
  audio.volume = 1;
}

function toggleMusic() {
  const btn = document.getElementById('btn-music');
  if (musicPlaying) {
    audio.pause();
    btn.textContent = 'ğŸµ éŸ³ä¹';
    btn.classList.remove('active');
  } else {
    audio.play().catch(() => {});
    btn.textContent = 'ğŸ”‡ é™éŸ³';
    btn.classList.add('active');
  }
  musicPlaying = !musicPlaying;
}

// ============ äº¤äº’ ============
function startExperience() {
  document.getElementById('tap-hint').classList.add('hidden');
  // å°è¯•æ’­æ”¾éŸ³ä¹
  audio.play().then(() => {
    musicPlaying = true;
    document.getElementById('btn-music').textContent = 'ğŸ”‡ é™éŸ³';
    document.getElementById('btn-music').classList.add('active');
  }).catch(() => {});
}

function onTap(event) {
  if (event.target.closest('.btn') || event.target.closest('#tap-hint')) return;

  // è·å–ç‚¹å‡»ä½ç½®åˆ›å»ºçƒŸèŠ±
  const rect = renderer.domElement.getBoundingClientRect();
  const x = ((event.clientX || event.changedTouches?.[0]?.clientX || 0) - rect.left) / rect.width * 2 - 1;
  const y = -((event.clientY || event.changedTouches?.[0]?.clientY || 0) - rect.top) / rect.height * 2 + 1;

  // åœ¨éšæœºä½ç½®åˆ›å»ºçƒŸèŠ±
  const fireworkX = x * 8;
  const fireworkY = 5 + Math.random() * 5;
  const fireworkZ = -2 + Math.random() * 4;

  fireworks.push(new Firework(fireworkX, fireworkY, fireworkZ));
}

function regenerate() {
  createTreeLights();
  createOrnaments();
  createTinsel();
  createGifts();
  createSnow();
  createConfetti();
}

function togglePause() {
  running = !running;
  const btn = document.getElementById('btn-pause');
  btn.textContent = running ? 'â¸ï¸ æš‚åœ' : 'â–¶ï¸ ç»§ç»­';
}

function resetCamera() {
  controls.reset();
  camera.position.set(0, 3, 12);
  controls.target.set(0, 2, 0);
}

function onResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

// ============ åŠ¨ç”»å¾ªç¯ ============
function animate() {
  requestAnimationFrame(animate);

  if (!running) {
    controls.update();
    renderer.render(scene, camera);
    return;
  }

  const time = clock.getElapsedTime();
  const delta = clock.getDelta();

  // æ›´æ–°æ§åˆ¶å™¨
  controls.update();

  // æå…‰åŠ¨ç”»
  if (aurora) {
    aurora.material.uniforms.uTime.value = time;
  }

  // æ˜Ÿç©ºé—ªçƒ
  if (starParticles) {
    starParticles.material.uniforms.uTime.value = time;
  }

  // æ˜Ÿæ˜Ÿæ—‹è½¬
  if (star) {
    star.rotation.y += 0.01;
    star.rotation.z = Math.sin(time * 2) * 0.1;
  }

  // å½©ç¯é—ªçƒ
  treeLights.forEach(light => {
    const data = light.userData;
    const brightness = 0.5 + Math.sin(time * data.speed + data.phase) * 0.5;
    light.material.opacity = 0.6 + brightness * 0.4;
    light.scale.setScalar(0.8 + brightness * 0.4);
  });

  // ç¤¼ç‰©è½»å¾®å¼¹è·³
  gifts.forEach(gift => {
    gift.position.y = gift.userData.baseY + Math.sin(time * 2 + gift.userData.bouncePhase) * 0.05;
  });

  // è£…é¥°çƒè½»å¾®æ‘‡æ‘†
  ornaments.forEach(ornament => {
    const swing = Math.sin(time * ornament.userData.swingSpeed + ornament.userData.phase) * 0.02;
    ornament.position.x += swing * 0.1;
  });

  // è·³èˆå°äººåŠ¨ç”»
  dancers.forEach(dancer => {
    dancer.update(time);
  });

  // é›ªèŠ±é£˜è½
  if (snowParticles) {
    const positions = snowParticles.geometry.attributes.position.array;
    for (let i = 0; i < CONFIG.snowCount; i++) {
      positions[i * 3] += snowVelocities[i].x + Math.sin(time + i) * 0.002;
      positions[i * 3 + 1] -= snowVelocities[i].y;
      positions[i * 3 + 2] += snowVelocities[i].z;

      if (positions[i * 3 + 1] < -1) {
        positions[i * 3 + 1] = 25;
        positions[i * 3] = (Math.random() - 0.5) * 40;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 40;
      }
    }
    snowParticles.geometry.attributes.position.needsUpdate = true;
  }

  // å½©å¸¦é£˜è½
  if (confettiParticles) {
    const positions = confettiParticles.geometry.attributes.position.array;
    for (let i = 0; i < CONFIG.confettiCount; i++) {
      const vel = confettiVelocities[i];
      vel.swing += vel.swingSpeed;

      positions[i * 3] += vel.x + Math.sin(vel.swing) * 0.02;
      positions[i * 3 + 1] -= vel.y;
      positions[i * 3 + 2] += vel.z + Math.cos(vel.swing) * 0.02;

      if (positions[i * 3 + 1] < -1) {
        positions[i * 3 + 1] = 20 + Math.random() * 10;
        positions[i * 3] = (Math.random() - 0.5) * 30;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 30;
      }
    }
    confettiParticles.geometry.attributes.position.needsUpdate = true;
  }

  // æ›´æ–°çƒŸèŠ±
  fireworks = fireworks.filter(fw => {
    const alive = fw.update();
    if (!alive) fw.dispose();
    return alive;
  });

  // æ›´æ–°æµæ˜Ÿ
  meteors = meteors.filter(m => {
    const alive = m.update();
    if (!alive) m.dispose();
    return alive;
  });

  // éšæœºç”Ÿæˆæµæ˜Ÿ
  if (Math.random() < 0.003 && meteors.length < 2) {
    meteors.push(new Meteor());
  }

  renderer.render(scene, camera);
}

// å¯åŠ¨
init();
</script>
</body>
</html>
