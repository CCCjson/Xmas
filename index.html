<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>ğŸ„ Merry Christmas</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%; height: 100%; overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "PingFang SC", sans-serif;
      touch-action: none;
    }
    #container { width: 100%; height: 100%; position: relative; }
    canvas { display: block; }

    /* åŠ è½½ç•Œé¢ */
    #loading {
      position: fixed; inset: 0; z-index: 1000;
      background: radial-gradient(ellipse at top, #1a0a2e 0%, #0d0015 100%);
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      color: #fff; transition: opacity 0.8s ease;
    }
    #loading.hidden { opacity: 0; pointer-events: none; }
    .loading-tree { font-size: 80px; animation: bounce 1s infinite; }
    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-20px); }
    }
    .loading-text { margin-top: 20px; font-size: 18px; opacity: 0.8; }
    .loading-hint { margin-top: 30px; font-size: 14px; opacity: 0.5; }

    /* UI æ§ä»¶ */
    #ui {
      position: fixed; bottom: 0; left: 0; right: 0;
      padding: 15px 10px 25px; z-index: 100;
      background: linear-gradient(to top, rgba(0,0,0,0.6) 0%, transparent 100%);
    }
    .title {
      text-align: center; color: #fff; font-size: 22px; font-weight: 600;
      text-shadow: 0 0 20px rgba(255,200,100,0.8), 0 0 40px rgba(255,150,50,0.5);
      margin-bottom: 15px; letter-spacing: 2px;
    }
    .btns {
      display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;
    }
    .btn {
      border: 1px solid rgba(255,255,255,0.3);
      background: rgba(255,255,255,0.1);
      backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
      color: #fff; padding: 10px 16px; border-radius: 25px;
      font-size: 14px; cursor: pointer;
      transition: all 0.3s ease;
      display: flex; align-items: center; gap: 6px;
    }
    .btn:hover { background: rgba(255,255,255,0.2); transform: scale(1.05); }
    .btn:active { transform: scale(0.95); }
    .btn.active { background: rgba(255,200,100,0.3); border-color: rgba(255,200,100,0.6); }

    /* æç¤ºæ–‡å­— */
    .hint {
      position: fixed; top: 15px; left: 50%; transform: translateX(-50%);
      color: rgba(255,255,255,0.6); font-size: 12px; text-align: center;
      pointer-events: none; z-index: 100;
    }

    /* ç‚¹å‡»æç¤º */
    .tap-hint {
      position: fixed; inset: 0; z-index: 999;
      background: rgba(0,0,0,0.7);
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      color: #fff; cursor: pointer;
    }
    .tap-hint.hidden { display: none; }
    .tap-icon { font-size: 60px; animation: pulse 1.5s infinite; }
    @keyframes pulse {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.1); opacity: 0.7; }
    }
    .tap-text { margin-top: 20px; font-size: 16px; }
  </style>
</head>
<body>
  <!-- åŠ è½½ç•Œé¢ -->
  <div id="loading">
    <div class="loading-tree">ğŸ„</div>
    <div class="loading-text">æ­£åœ¨å‡†å¤‡åœ£è¯æƒŠå–œ...</div>
    <div class="loading-hint">é¦–æ¬¡åŠ è½½å¯èƒ½éœ€è¦å‡ ç§’é’Ÿ</div>
  </div>

  <!-- ç‚¹å‡»å¼€å§‹æç¤º -->
  <div id="tap-hint" class="tap-hint hidden">
    <div class="tap-icon">ğŸ‘†</div>
    <div class="tap-text">ç‚¹å‡»å±å¹•å¼€å§‹ä½“éªŒ</div>
  </div>

  <!-- 3D å®¹å™¨ -->
  <div id="container"></div>

  <!-- é¡¶éƒ¨æç¤º -->
  <div class="hint">æ»‘åŠ¨æ—‹è½¬ Â· åŒæŒ‡ç¼©æ”¾ Â· ç‚¹å‡»æ”¾çƒŸèŠ±</div>

  <!-- åº•éƒ¨UI -->
  <div id="ui">
    <div class="title">âœ¨ Merry Christmas âœ¨</div>
    <div class="btns">
      <button class="btn" id="btn-regen">ğŸ„ æ¢ä¸€æ£µ</button>
      <button class="btn" id="btn-pause">â¸ï¸ æš‚åœ</button>
      <button class="btn" id="btn-music">ğŸµ éŸ³ä¹</button>
      <button class="btn" id="btn-reset">ğŸ”„ è§†è§’</button>
    </div>
  </div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// ============ é…ç½® ============
const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
const CONFIG = {
  snowCount: isMobile ? 200 : 400,
  confettiCount: isMobile ? 80 : 150,
  lightCount: isMobile ? 50 : 80,
  starCount: isMobile ? 100 : 200,
};

// ============ å…¨å±€å˜é‡ ============
let scene, camera, renderer, controls;
let running = true;
let musicPlaying = false;
let audio;
let clock = new THREE.Clock();

// ç²’å­ç³»ç»Ÿ
let snowParticles, confettiParticles, starParticles;
let snowPositions, snowVelocities;
let confettiPositions, confettiVelocities, confettiRotations;

// å¯¹è±¡
let treeLights = [];
let star;
let gifts = [];
let fireworks = [];
let meteors = [];
let aurora;

// ============ åˆå§‹åŒ– ============
function init() {
  // åœºæ™¯
  scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x0a0015, 0.015);

  // ç›¸æœº
  camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 3, 12);

  // æ¸²æŸ“å™¨
  renderer = new THREE.WebGLRenderer({
    antialias: !isMobile,
    alpha: true,
    powerPreference: 'high-performance'
  });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.2;
  document.getElementById('container').appendChild(renderer.domElement);

  // æ§åˆ¶å™¨
  controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;
  controls.maxDistance = 25;
  controls.minDistance = 5;
  controls.maxPolarAngle = Math.PI * 0.85;
  controls.minPolarAngle = Math.PI * 0.1;
  controls.autoRotate = true;
  controls.autoRotateSpeed = 0.5;
  controls.target.set(0, 2, 0);

  // å…‰ç…§
  setupLights();

  // åˆ›å»ºåœºæ™¯ç‰©ä½“
  createAurora();
  createStarField();
  createGround();
  createTree();
  createStar();
  createTreeLights();
  createGifts();
  createSnow();
  createConfetti();

  // äº‹ä»¶ç›‘å¬
  window.addEventListener('resize', onResize);
  renderer.domElement.addEventListener('click', onTap);
  renderer.domElement.addEventListener('touchend', onTap);

  // æŒ‰é’®äº‹ä»¶
  document.getElementById('btn-regen').addEventListener('click', regenerate);
  document.getElementById('btn-pause').addEventListener('click', togglePause);
  document.getElementById('btn-music').addEventListener('click', toggleMusic);
  document.getElementById('btn-reset').addEventListener('click', resetCamera);

  // éšè—åŠ è½½ç•Œé¢
  setTimeout(() => {
    document.getElementById('loading').classList.add('hidden');
    document.getElementById('tap-hint').classList.remove('hidden');
  }, 1500);

  // ç‚¹å‡»å¼€å§‹
  document.getElementById('tap-hint').addEventListener('click', startExperience);

  // è®¾ç½®éŸ³é¢‘
  setupAudio();

  // å¼€å§‹åŠ¨ç”»
  animate();
}

function setupLights() {
  // ç¯å¢ƒå…‰
  const ambient = new THREE.AmbientLight(0x404060, 0.4);
  scene.add(ambient);

  // ä¸»å…‰æº
  const mainLight = new THREE.DirectionalLight(0xffeedd, 0.8);
  mainLight.position.set(5, 10, 5);
  scene.add(mainLight);

  // åº•éƒ¨æš–å…‰
  const warmLight = new THREE.PointLight(0xff8844, 0.6, 20);
  warmLight.position.set(0, 0.5, 3);
  scene.add(warmLight);

  // é¡¶éƒ¨æ˜Ÿå…‰
  const starLight = new THREE.PointLight(0xffffaa, 1, 15);
  starLight.position.set(0, 7, 0);
  scene.add(starLight);
}

// ============ æå…‰æ•ˆæœ ============
function createAurora() {
  const auroraGeo = new THREE.PlaneGeometry(100, 40, 50, 20);
  const auroraMat = new THREE.ShaderMaterial({
    uniforms: {
      uTime: { value: 0 },
      uColor1: { value: new THREE.Color(0x00ff88) },
      uColor2: { value: new THREE.Color(0x0088ff) },
      uColor3: { value: new THREE.Color(0xff00aa) },
    },
    vertexShader: `
      varying vec2 vUv;
      varying float vY;
      uniform float uTime;
      void main() {
        vUv = uv;
        vec3 pos = position;
        pos.z += sin(pos.x * 0.1 + uTime * 0.5) * 2.0;
        pos.z += sin(pos.y * 0.2 + uTime * 0.3) * 1.5;
        vY = pos.y;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
      }
    `,
    fragmentShader: `
      uniform float uTime;
      uniform vec3 uColor1;
      uniform vec3 uColor2;
      uniform vec3 uColor3;
      varying vec2 vUv;
      varying float vY;
      void main() {
        float wave = sin(vUv.x * 10.0 + uTime) * 0.5 + 0.5;
        float wave2 = sin(vUv.x * 5.0 - uTime * 0.7) * 0.5 + 0.5;
        vec3 color = mix(uColor1, uColor2, wave);
        color = mix(color, uColor3, wave2 * 0.3);
        float alpha = smoothstep(0.0, 0.5, vUv.y) * smoothstep(1.0, 0.6, vUv.y);
        alpha *= 0.3 + wave * 0.2;
        alpha *= smoothstep(-20.0, 0.0, vY);
        gl_FragColor = vec4(color, alpha * 0.4);
      }
    `,
    transparent: true,
    side: THREE.DoubleSide,
    depthWrite: false,
  });

  aurora = new THREE.Mesh(auroraGeo, auroraMat);
  aurora.position.set(0, 25, -40);
  aurora.rotation.x = Math.PI * 0.1;
  scene.add(aurora);
}

// ============ æ˜Ÿç©ºèƒŒæ™¯ ============
function createStarField() {
  const geometry = new THREE.BufferGeometry();
  const positions = new Float32Array(CONFIG.starCount * 3);
  const sizes = new Float32Array(CONFIG.starCount);

  for (let i = 0; i < CONFIG.starCount; i++) {
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.random() * Math.PI * 0.5;
    const r = 50 + Math.random() * 50;

    positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
    positions[i * 3 + 1] = r * Math.cos(phi) + 10;
    positions[i * 3 + 2] = r * Math.sin(phi) * Math.sin(theta) - 20;
    sizes[i] = Math.random() * 2 + 0.5;
  }

  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

  const material = new THREE.ShaderMaterial({
    uniforms: {
      uTime: { value: 0 },
    },
    vertexShader: `
      attribute float size;
      varying float vSize;
      void main() {
        vSize = size;
        vec4 mvPos = modelViewMatrix * vec4(position, 1.0);
        gl_PointSize = size * (200.0 / -mvPos.z);
        gl_Position = projectionMatrix * mvPos;
      }
    `,
    fragmentShader: `
      uniform float uTime;
      varying float vSize;
      void main() {
        float d = length(gl_PointCoord - 0.5);
        if (d > 0.5) discard;
        float alpha = 1.0 - d * 2.0;
        float twinkle = sin(uTime * 3.0 + vSize * 10.0) * 0.3 + 0.7;
        gl_FragColor = vec4(1.0, 1.0, 0.95, alpha * twinkle);
      }
    `,
    transparent: true,
    depthWrite: false,
  });

  starParticles = new THREE.Points(geometry, material);
  scene.add(starParticles);
}

// ============ åœ°é¢ ============
function createGround() {
  const groundGeo = new THREE.CircleGeometry(30, 64);
  const groundMat = new THREE.MeshStandardMaterial({
    color: 0xffffff,
    roughness: 0.9,
    metalness: 0.1,
  });
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI / 2;
  ground.position.y = -0.5;
  ground.receiveShadow = true;
  scene.add(ground);
}

// ============ åœ£è¯æ ‘ ============
function createTree() {
  const treeMaterial = new THREE.MeshStandardMaterial({
    color: 0x0d5c2e,
    roughness: 0.8,
    metalness: 0.1,
  });

  const darkTreeMaterial = new THREE.MeshStandardMaterial({
    color: 0x0a4a24,
    roughness: 0.8,
    metalness: 0.1,
  });

  // å¤šå±‚æ ‘å† 
  const layers = [
    { y: 5.5, radius: 0.8, height: 2 },
    { y: 4.2, radius: 1.3, height: 2.2 },
    { y: 2.7, radius: 1.9, height: 2.5 },
    { y: 1.0, radius: 2.5, height: 2.8 },
  ];

  layers.forEach((layer, i) => {
    const geo = new THREE.ConeGeometry(layer.radius, layer.height, 32);
    const mat = i % 2 === 0 ? treeMaterial : darkTreeMaterial;
    const cone = new THREE.Mesh(geo, mat);
    cone.position.y = layer.y;
    cone.castShadow = true;
    scene.add(cone);
  });

  // æ ‘å¹²
  const trunkGeo = new THREE.CylinderGeometry(0.3, 0.4, 1.2, 16);
  const trunkMat = new THREE.MeshStandardMaterial({
    color: 0x4a3020,
    roughness: 0.9,
  });
  const trunk = new THREE.Mesh(trunkGeo, trunkMat);
  trunk.position.y = -0.1;
  scene.add(trunk);
}

// ============ æ ‘é¡¶æ˜Ÿæ˜Ÿ ============
function createStar() {
  const starShape = new THREE.Shape();
  const outerRadius = 0.5;
  const innerRadius = 0.2;
  const spikes = 5;

  for (let i = 0; i < spikes * 2; i++) {
    const radius = i % 2 === 0 ? outerRadius : innerRadius;
    const angle = (i * Math.PI) / spikes - Math.PI / 2;
    const x = Math.cos(angle) * radius;
    const y = Math.sin(angle) * radius;
    if (i === 0) starShape.moveTo(x, y);
    else starShape.lineTo(x, y);
  }
  starShape.closePath();

  const extrudeSettings = { depth: 0.15, bevelEnabled: true, bevelSize: 0.05, bevelThickness: 0.05 };
  const starGeo = new THREE.ExtrudeGeometry(starShape, extrudeSettings);
  const starMat = new THREE.MeshStandardMaterial({
    color: 0xffd700,
    emissive: 0xffaa00,
    emissiveIntensity: 0.8,
    roughness: 0.3,
    metalness: 0.8,
  });

  star = new THREE.Mesh(starGeo, starMat);
  star.position.set(0, 6.8, 0);
  star.rotation.y = Math.PI / 2;
  scene.add(star);

  // æ˜Ÿæ˜Ÿå…‰æ™•
  const glowGeo = new THREE.SphereGeometry(0.6, 16, 16);
  const glowMat = new THREE.MeshBasicMaterial({
    color: 0xffdd44,
    transparent: true,
    opacity: 0.3,
  });
  const glow = new THREE.Mesh(glowGeo, glowMat);
  glow.position.copy(star.position);
  scene.add(glow);
}

// ============ å½©ç¯ ============
function createTreeLights() {
  treeLights.forEach(light => scene.remove(light));
  treeLights = [];

  const colors = [0xff4444, 0x44ff44, 0x4444ff, 0xffff44, 0xff44ff, 0x44ffff, 0xffffff];

  for (let i = 0; i < CONFIG.lightCount; i++) {
    const t = Math.random();
    const y = 0.5 + t * 5.5;
    const maxRadius = 2.5 * (1 - t * 0.7);
    const angle = Math.random() * Math.PI * 2;
    const radius = maxRadius * (0.7 + Math.random() * 0.3);

    const x = Math.cos(angle) * radius;
    const z = Math.sin(angle) * radius;

    const geometry = new THREE.SphereGeometry(0.08, 8, 8);
    const color = colors[Math.floor(Math.random() * colors.length)];
    const material = new THREE.MeshBasicMaterial({
      color: color,
      transparent: true,
    });

    const light = new THREE.Mesh(geometry, material);
    light.position.set(x, y, z);
    light.userData = {
      baseColor: color,
      phase: Math.random() * Math.PI * 2,
      speed: 1 + Math.random() * 2,
    };

    scene.add(light);
    treeLights.push(light);
  }
}

// ============ ç¤¼ç‰©ç›’ ============
function createGifts() {
  gifts.forEach(g => scene.remove(g));
  gifts = [];

  const giftData = [
    { pos: [-1.5, 0, 2], size: [0.6, 0.5, 0.6], color: 0xff4444, ribbon: 0xffd700 },
    { pos: [0, 0, 2.5], size: [0.8, 0.7, 0.8], color: 0x4444ff, ribbon: 0xffffff },
    { pos: [1.8, 0, 1.8], size: [0.5, 0.4, 0.5], color: 0x44ff44, ribbon: 0xff4444 },
    { pos: [0.8, 0, 2.8], size: [0.55, 0.45, 0.55], color: 0xff44ff, ribbon: 0x44ffff },
  ];

  giftData.forEach(data => {
    const group = new THREE.Group();

    // ç›’å­
    const boxGeo = new THREE.BoxGeometry(...data.size);
    const boxMat = new THREE.MeshStandardMaterial({
      color: data.color,
      roughness: 0.4,
      metalness: 0.3,
    });
    const box = new THREE.Mesh(boxGeo, boxMat);
    box.position.y = data.size[1] / 2;
    group.add(box);

    // ä¸å¸¦
    const ribbonMat = new THREE.MeshStandardMaterial({
      color: data.ribbon,
      roughness: 0.3,
      metalness: 0.5,
    });

    const ribbonV = new THREE.Mesh(
      new THREE.BoxGeometry(data.size[0] * 0.15, data.size[1] * 1.02, data.size[2] * 1.02),
      ribbonMat
    );
    ribbonV.position.y = data.size[1] / 2;
    group.add(ribbonV);

    const ribbonH = new THREE.Mesh(
      new THREE.BoxGeometry(data.size[0] * 1.02, data.size[1] * 0.15, data.size[2] * 1.02),
      ribbonMat
    );
    ribbonH.position.y = data.size[1] / 2;
    group.add(ribbonH);

    group.position.set(...data.pos);
    group.userData.baseY = data.pos[1];
    group.userData.bouncePhase = Math.random() * Math.PI * 2;

    scene.add(group);
    gifts.push(group);
  });
}

// ============ é›ªèŠ±ç²’å­ ============
function createSnow() {
  if (snowParticles) scene.remove(snowParticles);

  const geometry = new THREE.BufferGeometry();
  snowPositions = new Float32Array(CONFIG.snowCount * 3);
  snowVelocities = [];

  for (let i = 0; i < CONFIG.snowCount; i++) {
    snowPositions[i * 3] = (Math.random() - 0.5) * 40;
    snowPositions[i * 3 + 1] = Math.random() * 30;
    snowPositions[i * 3 + 2] = (Math.random() - 0.5) * 40;

    snowVelocities.push({
      y: 0.02 + Math.random() * 0.03,
      x: (Math.random() - 0.5) * 0.01,
      z: (Math.random() - 0.5) * 0.01,
    });
  }

  geometry.setAttribute('position', new THREE.BufferAttribute(snowPositions, 3));

  const material = new THREE.PointsMaterial({
    color: 0xffffff,
    size: 0.15,
    transparent: true,
    opacity: 0.8,
    depthWrite: false,
  });

  snowParticles = new THREE.Points(geometry, material);
  scene.add(snowParticles);
}

// ============ å½©å¸¦ç²’å­ ============
function createConfetti() {
  if (confettiParticles) scene.remove(confettiParticles);

  const geometry = new THREE.BufferGeometry();
  confettiPositions = new Float32Array(CONFIG.confettiCount * 3);
  const colors = new Float32Array(CONFIG.confettiCount * 3);
  confettiVelocities = [];
  confettiRotations = [];

  const confettiColors = [
    new THREE.Color(0xff4444),
    new THREE.Color(0x44ff44),
    new THREE.Color(0x4444ff),
    new THREE.Color(0xffff44),
    new THREE.Color(0xff44ff),
    new THREE.Color(0x44ffff),
  ];

  for (let i = 0; i < CONFIG.confettiCount; i++) {
    confettiPositions[i * 3] = (Math.random() - 0.5) * 30;
    confettiPositions[i * 3 + 1] = 10 + Math.random() * 20;
    confettiPositions[i * 3 + 2] = (Math.random() - 0.5) * 30;

    const color = confettiColors[Math.floor(Math.random() * confettiColors.length)];
    colors[i * 3] = color.r;
    colors[i * 3 + 1] = color.g;
    colors[i * 3 + 2] = color.b;

    confettiVelocities.push({
      y: 0.01 + Math.random() * 0.02,
      x: (Math.random() - 0.5) * 0.02,
      z: (Math.random() - 0.5) * 0.02,
      swing: Math.random() * Math.PI * 2,
      swingSpeed: 0.02 + Math.random() * 0.03,
    });
  }

  geometry.setAttribute('position', new THREE.BufferAttribute(confettiPositions, 3));
  geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

  const material = new THREE.PointsMaterial({
    size: 0.2,
    vertexColors: true,
    transparent: true,
    opacity: 0.9,
    depthWrite: false,
  });

  confettiParticles = new THREE.Points(geometry, material);
  scene.add(confettiParticles);
}

// ============ çƒŸèŠ±ç³»ç»Ÿ ============
class Firework {
  constructor(x, y, z) {
    this.particles = [];
    this.geometry = new THREE.BufferGeometry();
    this.particleCount = isMobile ? 50 : 100;
    this.positions = new Float32Array(this.particleCount * 3);
    this.velocities = [];
    this.life = 1;
    this.decay = 0.015;

    const color = new THREE.Color().setHSL(Math.random(), 1, 0.6);

    for (let i = 0; i < this.particleCount; i++) {
      this.positions[i * 3] = x;
      this.positions[i * 3 + 1] = y;
      this.positions[i * 3 + 2] = z;

      const theta = Math.random() * Math.PI * 2;
      const phi = Math.random() * Math.PI;
      const speed = 0.1 + Math.random() * 0.15;

      this.velocities.push({
        x: Math.sin(phi) * Math.cos(theta) * speed,
        y: Math.sin(phi) * Math.sin(theta) * speed,
        z: Math.cos(phi) * speed,
      });
    }

    this.geometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));

    this.material = new THREE.PointsMaterial({
      color: color,
      size: 0.15,
      transparent: true,
      opacity: 1,
      depthWrite: false,
    });

    this.points = new THREE.Points(this.geometry, this.material);
    scene.add(this.points);
  }

  update() {
    this.life -= this.decay;
    this.material.opacity = this.life;

    for (let i = 0; i < this.particleCount; i++) {
      this.positions[i * 3] += this.velocities[i].x;
      this.positions[i * 3 + 1] += this.velocities[i].y;
      this.positions[i * 3 + 2] += this.velocities[i].z;

      this.velocities[i].y -= 0.002; // é‡åŠ›
      this.velocities[i].x *= 0.98;
      this.velocities[i].z *= 0.98;
    }

    this.geometry.attributes.position.needsUpdate = true;

    return this.life > 0;
  }

  dispose() {
    scene.remove(this.points);
    this.geometry.dispose();
    this.material.dispose();
  }
}

// ============ æµæ˜Ÿç³»ç»Ÿ ============
class Meteor {
  constructor() {
    this.geometry = new THREE.BufferGeometry();
    const trailLength = 20;
    this.positions = new Float32Array(trailLength * 3);

    this.startX = 20 + Math.random() * 10;
    this.startY = 15 + Math.random() * 10;
    this.startZ = -20 + Math.random() * 10;

    this.speed = 0.5 + Math.random() * 0.3;
    this.progress = 0;
    this.trailLength = trailLength;

    for (let i = 0; i < trailLength; i++) {
      this.positions[i * 3] = this.startX;
      this.positions[i * 3 + 1] = this.startY;
      this.positions[i * 3 + 2] = this.startZ;
    }

    this.geometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));

    this.material = new THREE.LineBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.8,
    });

    this.line = new THREE.Line(this.geometry, this.material);
    scene.add(this.line);
  }

  update() {
    this.progress += this.speed;

    const headX = this.startX - this.progress * 0.8;
    const headY = this.startY - this.progress * 0.4;
    const headZ = this.startZ + this.progress * 0.2;

    for (let i = this.trailLength - 1; i > 0; i--) {
      this.positions[i * 3] = this.positions[(i - 1) * 3];
      this.positions[i * 3 + 1] = this.positions[(i - 1) * 3 + 1];
      this.positions[i * 3 + 2] = this.positions[(i - 1) * 3 + 2];
    }

    this.positions[0] = headX;
    this.positions[1] = headY;
    this.positions[2] = headZ;

    this.geometry.attributes.position.needsUpdate = true;

    this.material.opacity = Math.max(0, 1 - this.progress / 40);

    return this.progress < 50;
  }

  dispose() {
    scene.remove(this.line);
    this.geometry.dispose();
    this.material.dispose();
  }
}

// ============ éŸ³é¢‘ç³»ç»Ÿ ============
function setupAudio() {
  audio = new Audio();
  audio.src = './Mariah Carey - All I Want for Christmas Is You.flac';
  audio.loop = true;
  audio.volume = 0.3;
}

function toggleMusic() {
  const btn = document.getElementById('btn-music');
  if (musicPlaying) {
    audio.pause();
    btn.textContent = 'ğŸµ éŸ³ä¹';
    btn.classList.remove('active');
  } else {
    audio.play().catch(() => {});
    btn.textContent = 'ğŸ”‡ é™éŸ³';
    btn.classList.add('active');
  }
  musicPlaying = !musicPlaying;
}

// ============ äº¤äº’ ============
function startExperience() {
  document.getElementById('tap-hint').classList.add('hidden');
  // å°è¯•æ’­æ”¾éŸ³ä¹
  audio.play().then(() => {
    musicPlaying = true;
    document.getElementById('btn-music').textContent = 'ğŸ”‡ é™éŸ³';
    document.getElementById('btn-music').classList.add('active');
  }).catch(() => {});
}

function onTap(event) {
  if (event.target.closest('.btn') || event.target.closest('#tap-hint')) return;

  // è·å–ç‚¹å‡»ä½ç½®åˆ›å»ºçƒŸèŠ±
  const rect = renderer.domElement.getBoundingClientRect();
  const x = ((event.clientX || event.changedTouches?.[0]?.clientX || 0) - rect.left) / rect.width * 2 - 1;
  const y = -((event.clientY || event.changedTouches?.[0]?.clientY || 0) - rect.top) / rect.height * 2 + 1;

  // åœ¨éšæœºä½ç½®åˆ›å»ºçƒŸèŠ±
  const fireworkX = x * 8;
  const fireworkY = 5 + Math.random() * 5;
  const fireworkZ = -2 + Math.random() * 4;

  fireworks.push(new Firework(fireworkX, fireworkY, fireworkZ));
}

function regenerate() {
  createTreeLights();
  createGifts();
  createSnow();
  createConfetti();
}

function togglePause() {
  running = !running;
  const btn = document.getElementById('btn-pause');
  btn.textContent = running ? 'â¸ï¸ æš‚åœ' : 'â–¶ï¸ ç»§ç»­';
}

function resetCamera() {
  controls.reset();
  camera.position.set(0, 3, 12);
  controls.target.set(0, 2, 0);
}

function onResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

// ============ åŠ¨ç”»å¾ªç¯ ============
function animate() {
  requestAnimationFrame(animate);

  if (!running) {
    controls.update();
    renderer.render(scene, camera);
    return;
  }

  const time = clock.getElapsedTime();
  const delta = clock.getDelta();

  // æ›´æ–°æ§åˆ¶å™¨
  controls.update();

  // æå…‰åŠ¨ç”»
  if (aurora) {
    aurora.material.uniforms.uTime.value = time;
  }

  // æ˜Ÿç©ºé—ªçƒ
  if (starParticles) {
    starParticles.material.uniforms.uTime.value = time;
  }

  // æ˜Ÿæ˜Ÿæ—‹è½¬
  if (star) {
    star.rotation.y += 0.01;
    star.rotation.z = Math.sin(time * 2) * 0.1;
  }

  // å½©ç¯é—ªçƒ
  treeLights.forEach(light => {
    const data = light.userData;
    const brightness = 0.5 + Math.sin(time * data.speed + data.phase) * 0.5;
    light.material.opacity = 0.6 + brightness * 0.4;
    light.scale.setScalar(0.8 + brightness * 0.4);
  });

  // ç¤¼ç‰©è½»å¾®å¼¹è·³
  gifts.forEach(gift => {
    gift.position.y = gift.userData.baseY + Math.sin(time * 2 + gift.userData.bouncePhase) * 0.05;
  });

  // é›ªèŠ±é£˜è½
  if (snowParticles) {
    const positions = snowParticles.geometry.attributes.position.array;
    for (let i = 0; i < CONFIG.snowCount; i++) {
      positions[i * 3] += snowVelocities[i].x + Math.sin(time + i) * 0.002;
      positions[i * 3 + 1] -= snowVelocities[i].y;
      positions[i * 3 + 2] += snowVelocities[i].z;

      if (positions[i * 3 + 1] < -1) {
        positions[i * 3 + 1] = 25;
        positions[i * 3] = (Math.random() - 0.5) * 40;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 40;
      }
    }
    snowParticles.geometry.attributes.position.needsUpdate = true;
  }

  // å½©å¸¦é£˜è½
  if (confettiParticles) {
    const positions = confettiParticles.geometry.attributes.position.array;
    for (let i = 0; i < CONFIG.confettiCount; i++) {
      const vel = confettiVelocities[i];
      vel.swing += vel.swingSpeed;

      positions[i * 3] += vel.x + Math.sin(vel.swing) * 0.02;
      positions[i * 3 + 1] -= vel.y;
      positions[i * 3 + 2] += vel.z + Math.cos(vel.swing) * 0.02;

      if (positions[i * 3 + 1] < -1) {
        positions[i * 3 + 1] = 20 + Math.random() * 10;
        positions[i * 3] = (Math.random() - 0.5) * 30;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 30;
      }
    }
    confettiParticles.geometry.attributes.position.needsUpdate = true;
  }

  // æ›´æ–°çƒŸèŠ±
  fireworks = fireworks.filter(fw => {
    const alive = fw.update();
    if (!alive) fw.dispose();
    return alive;
  });

  // æ›´æ–°æµæ˜Ÿ
  meteors = meteors.filter(m => {
    const alive = m.update();
    if (!alive) m.dispose();
    return alive;
  });

  // éšæœºç”Ÿæˆæµæ˜Ÿ
  if (Math.random() < 0.003 && meteors.length < 2) {
    meteors.push(new Meteor());
  }

  renderer.render(scene, camera);
}

// å¯åŠ¨
init();
</script>
</body>
</html>
